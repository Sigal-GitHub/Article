#### MySQL 数据类型

###### 整数类型

`TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT`

属性： UNSIGNED 非负

整型指定宽度，int(11) 11 代表的是显示的宽度，并不影响实际的范围，对大多数应用来说是没有意义的，不会限制值得合法范围，只会影响显示字符的个数

###### 实数类型

`FLOAT, DOUBLE, DECIMAL`

decimal 可以存储比 bigint 还大的整数，可以用于存储精确的小数

float 和 double 类型支持使用标准的浮点进行近似的计算

对于计算来说，float 和 double 效率会更高一些

decimal 可以理解成将数字当成字符串来处理，所以存储的内容会更大

###### 字符串类型

`VARCHAR, CHAR, TEXT, BLOB`

varchar 可变长度字符串，比 char 更节省空间

varchar 如果存储内容超出指定长度，就会被截断

CHAR 是定长的，根据字符串长度分配足够的空间

CHAR 会根据需要采用空格进行填充以方便比较

CHAR 适合存储很短的字符串，或者定长的字符串,和 varchar 一样，超出长度会被截断

对于经常变更的数据来说， char 比 varchar 更好，char 不容易产生碎片

对于非常短的列，char 比 varchar 在存储空间上更有效率，只分配真正需要的空间，更长的列会小号更多的内存

尽量避免使用 BLOB/TEXT 类型，查询会使用临时表，导致严重的性能开销

###### 枚举类型

`ENUM`

有时可以使用枚举代替常用的字符串类型,把不重复的集合存储成一个预定义的集合

枚举类型内部存储的是整数，非常紧凑，把列表之压缩到一个或两个字节

尽量避免使用数字作为 ENUM 枚举的常量,易混乱

排序是按照内部存储的整数进行排序

枚举表会使表大小大大减小

###### 日期和时间类型

`TIMESTAMP, DATETIME`

尽量使用 TIMESTAMP，比 DATETIME 空间效率更高

用整数保存时间戳的格式通常不方便处理

如果需要存储微秒，可以使用 bigint 存储

> 列属性：auto_increment,default,not null,zerofill

#### MySQL 数据表引擎

###### InnoDB 表引擎

-   默认事务型引擎,最重要最广泛的存储引擎,性能非常优秀,数据存储在共享表空间,可以通过配置分开

-   对主键查询的性能高于其他类型的存储引擎

-   内部做了很多优化,从磁盘读取数据时自动在内存构建 hash 索引，插入数据时自动构建插入缓冲区

-   通过一些机制和工具支持真正的热备份

-   支持崩溃后的安全恢复

-   支持行级锁

-   支持外键

###### MyISAM 表引擎

-   5.1 版本前, MyISAM 是默认的存储引擎

-   拥有全文索引、压缩、空间函数

-   不支持事务和行级锁,不支持崩溃后的安全恢复

-   表存储在两个文件, MYD 和 MYI

-   设计简单,某些场景下性能很好(如获取表里有多少条数据,大小)

###### 其他表引擎

Archiv ，Blackhole，CSV，Memory

###### 选择表引擎

优先 InnoDB

#### 锁机制

表锁是日常开发当中常见的问题,当多个查询同一时刻进行数据修改时,就会产生并发控制的问题。

表锁分共享锁（读锁）和排他锁（写锁）

**读锁：** 共享的，不堵塞，多个用户可以同时读一个资源，互不干扰

**写锁：** 排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户读取正在写入的资源

锁粒度

表锁，系统性能开销最小，会锁定整张表，MyISAM 使用表锁

行锁，最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 实现行级锁

#### 事务处理

MySQL 提供事务处理的表引擎，InnoDB

服务器层部管理事务，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱

在非事务的表上执行事务操作，MySQL 不会发出提醒，也不会报错，所以在执行事务处理的时候，要检查表是否是支持事务的
