
> 索引使用的场景

- 对于非常小的表,大部分情况下全表扫描效率更高

- 中到大型表,索引非常有效

- 特大型的表,建立和使用索引的代价将随之增长,可以使用分区技术来解决

> 索引创建原则

- 最适合索引的列是出现在WHERE子句中的列,或连接子句中的列而不是出现在SELECT关键字后的列

- 索引列的基数越大,索引的效果越好

- 对字符串进行索引,应该制定一个前缀长度,可以节省大量的索引空间

- 根据情况创建复合索引,复合索引可以提高查询效率

- 避免创建过多索引,索引会额外占用磁盘空间,降低写操作效率                                                                                             
- 主键尽可能选择较短的数据类型,可以有效减少索引的磁盘占用提高查询效率

> 注意事项

- 组合索引的顺序

- LIKE查询 %不能在前面，不然索引失效，可以使用全文索引

- column is null 可以使用索引

- 如果 MySQL 估计使用索引比全盘扫描更慢，会放弃使用索引

- 如果 or 前的条件中的列有索引，后面的没有，索引都不会被使用

- 列类型是字符串，查询时一定要给值加引号，否则不使用索引


## 索引的含义和特点

索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有-特定值的行，所有`MySQL`列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。

例如

数据库中有2万条记录，现在要执行一个查询`SELECT * FROM table wherenum=10000`，如果没有索引，就必须遍历整个表，直到num等于10000的这一行被找到为止;

如果在num列上创建索引，`MySQL`不需要任何扫描，直接在索引里面找10000，就可以得知这一行的位置。

可见，索引的建立可以提高数据库的查询速度。

索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同， 并且每种存储引擎也不一定支持所有索引类型。根据存储引擎定义每个表的最大索引数和最大索引长度。

所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的限制。

MySQL中索引的存储类型有两种，即`BTREE`和`HASH`，具体和表的存储引擎相关; `MyISAM`和
`InnoDB`存储引擎只支持`BTREE`索引; `MEMORY/HEAP`存储引擎可以支持`HASH`和`BTREE`索引。

索引的优点主要有以下几条:

1. 通过创建唯-索引，可以保证数据库表中每一 行数据的唯一性
2. 可以大大加快数据的查询速度，这也是创建索引的主要原因
3. 在实现数据的参考完整性方面，可以加速表和表之间的连接
4. 在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间

增加索引也有许多不利的方面，主要表现在如下几个方面:

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度

## 索引的分类

1. 普通索引和唯一索引普通索引是`MySQL`中的基本索引类型，允许在定义索引的列中插入重复值和空值

唯一索引要求索引列的值必须唯一， 但允许有空值。如果是组合索引，则列值的组合必须唯主键索引是一种特殊的唯一索引，不允许有空值。

2. 单列索引和组合索引单列索引即一个索引只包含单个列，一个表可以有多个单列索引

组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。

3. 全文索引

全文索引类型为`FULLTEXT`，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在`CHAR`、`VARCHAR`或者`TEXT`类型的列上创建。`MySQL`中只有`MyISAM`存储引擎支持全文索引。

4. 空间索引

空间索引是对空间数据类型的字段建立的索引，`MySQL`中的空间数据类型有4种，分别是`GEOMETRY、POINT、LINESTRING和POLYGON`。`MySQL`使用`SPATIAL`关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为`NOT NULL`，空间索引只能在存储引擎为`MyISAM`的表中创建。

## 索引的设计原则

索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑以下准则:

1. 索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空间，还会影响`INSERT、DELETE、UPDATE`等语句的性能，因为在表中的数据更改时，索引也会进行调整和更新
2. 避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段
3. 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果

4. 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度

5. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度

6. 在频繁进行排序或分组(即进行`group by`或`order by`操作)的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引

## 创建索引

在创建表的定义语句`CREATE TABLE`中指定索引列，使用`ALTER TABLE`语句在存在的表上创建索引，或者使用`CREATE INDEX`语句在已存在的表上添加索引。

#### 创建表的时候创建索引

使用`CREATE TABLE`创建表时，除了可以定义列的数据类型，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。创建表时创建索引的基本语法格式如下:

![20210106134438](http://pic.sigalx.com/pic/20210106134438.png)

`UNIQUE、FULLTEXT 和SPATIAL`为可选参数，分别表示唯一索引、全文索引和空间索引;

`INDEX`与`KEY`为同义词，两者作用相同用来指定创建索引; `col_name`为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择; `index_name`指定索引的名称，为可选参数，如果不指定，`MySQL`默认`col_name`为索引值: `length` 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度; `ASC`或`DESC`指定升序或者降序的索引值存储。

- 创建普通索引

```sql
CREATE TABLE book (
    id INT NOT NULL,
    name VARCHAR(255) NOT NULL,
    authors VARCHAR(255) NOT NULL,
    info VARCHAR(255) NULL,
    INDEX(authors)
);
```
`SHOW CREATE TABLE book;`就能查看创建语句：

![20210106135701](http://pic.sigalx.com/pic/20210106135701.png)

使用`EXPLAIN`查看索引是否正在使用

![20210106135830](http://pic.sigalx.com/pic/20210106135830.png)

`EXPLAIN`语句输出结果的各个行解释如下:

1. `select_type`行指定所使用的`SELECT`查询类型，这里值为`SIMPLE`,表示简单的`SELECT`,不使用`UNION`或子查询。其他可能的取值有`PRIMARY、UNION、SUBQUERY`等

2. `table`行指定数据库读取的数据表的名字，它们按被读取的先后顺序排列

3. `type`行指定了本数据表与其他数据表之间的关联关系，可能的取值有`system、const、eq_ref、ref、range、index和All`

4. `possible_keys`行给出了`MySQL`在搜索数据记录时可选用的各个索引

5. `key`行是`MySQL`实际选用的索引

6. `key_len`行给出索引按字节计算的长度，`key_len`数值越小，表示越快

7. `ref`行给出了关联关系中另一个数据表里的数据列名

8. `rows`行是`MySQL`在执行这个查询时预计会从这个数据表里读出的数据行的个数

9. `Extra`行提供了与关联操作有关的信息

- 创建唯一索引

创建唯一索引的主要原因是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的就是:索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

```sql
例：创建名为UniqIdx的唯一索引
CREATE TABLE book 
(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    UNIQUE INDEX UniqIdx(id)
);
```

![20210106152038](http://pic.sigalx.com/pic/20210106152038.png)

- 创建单列索引

单列索引是在数据表中的某一个字段上创建的索引，一个表中可以创建多个单列索引，前面两个例子中创建的索引都为单列索引。

```sql
例：
CREATE TABLE book1
(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    INDEX SingleIdx(name(20))
);
```

索引长度为20；

- 创建组合索引

组合索引是在多个字段上创建一个索引。

```sql
例：
CREATE TABLE book2
(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    title VARCHAR(255) NOT NULL,
    INDEX MultiIdx(id,name,title)
);
```
组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”:利用索引中最左边的集来匹配行，这样的列集称为最左前缀。例如，这里由id、name和title 3个字段构成的索引，索引行中按id. name、title的顺序存放，索引可以搜索(id,name,title)、(id, name)或者id字段组合。如果列不构成索引最左面的前缀，那么MySQL不能使用局部索引，如(title) 或者(name,title) 组合则不能使用索引查询。

- 创建全文索引

`FULLTEXT`全文索引可以用于全文搜索。只有`MyISAM`存储引擎支持`FULLTEXT`索引，并且只为`CHAR、VARCHAR和TEXT`列创建索引。索引总是对整个列进行，不支持局部(前缀)索引。

```sql
例：
CREATE TABLE book 
(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    FULLTEXT INDEX FullTxtIdx(name)
);
```

全文索引非常适合于大型数据集，对于小的数据集，它的用处比较小。

- 创建空间索引

空间索引必须在`MyISAM`类型的表中创建，且空间类型的字段必须为非空。

```sql
例：
CREATE TABLE book 
(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    SPATIAL INDEX spatIdx(name)
);
```

#### 在已有表上创建索引

###### 查看索引

`SHOW INDEX FROM book \G`

![20210106153306](http://pic.sigalx.com/pic/20210106153306.png)

其中各个主要参数的含义为:

1. `Table`表示创建索引的表

2. `Non_unique`表示索引非唯一，1代表是非唯一索引，0代表唯一索引

3. `Key_name`表示索引的名称

4. `Seq_in_jindex`表示该字段在索引中的位置，单列索引该值为1,组合索引为每个字段在索引定义中的顺序

5. `Column_name`表示定义索引的列字段

6. `Sub_part` 表示索引的长度

7. `Null`表示该字段是否能为空值

8. `Index_type`表示索引类型


- ALTER TABLE

![20210106153038](http://pic.sigalx.com/pic/20210106153038.png)

`ALTER TABLE book ADD INDEX BkNameIdx(bookname(30));`

在已有的 book 表上添加名为 BkNameIdx 30长度的普通索引

`ALTER TABLE book ADD UNIQUE INDEX BkNameIdx(bookname);`

唯一索引

- CREATE INDEX

![20210106153905](http://pic.sigalx.com/pic/20210106153905.png)

`CREATE INDEX BkNameIdx ON book(bookname);`

`CREATE UNIQUE INDEX...`

## 删除索引

使用`ALTER TABLE`或者`DROP INDEX`语言删除索引，实现相同的功能。

#### ALTER TABLE 

`ALTER TABLE 表名 DROP INDEX 索引名;`

> 添加了`AUTO_INCREMENT`约束字段的唯一索引不能被删除

#### DROP INDEX

`DROP INDEX 索引名 ON 表名;`

> 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。